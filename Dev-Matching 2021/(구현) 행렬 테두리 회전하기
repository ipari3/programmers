# https://programmers.co.kr/learn/courses/30/lessons/77485


def solution(rows, columns, queries):
    board = [[i*columns + j + 1 for j in range(columns)] for i in range(rows)]

    min_sequence = []
    for query in queries:
        r1, c1, r2, c2 = (v - 1 for v in query)
        elements = []
        
        i = r1
        elements.append(board[i][c1])
        for j in range(c1+1, c2+1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        # j = c2
        for i in range(r1+1, r2+1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        # i = r2
        for j in range(c2-1, c1-1, -1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        # j = c1
        for i in range(r2-1, r1-1, -1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        min_sequence.append(min(elements))
    return min_sequence
    
"""
# 느낀 점
[구현은 담백하게 짜는 것이 좋다]
네모 모양을 이루며 회전이 이루어지는데, 이는 4개의 선분으로 나눌 수 있다.
따라서 4개의 for문으로 구현이 이루어진다.
또한 구하는 것은 결국 각 쿼리에서 회전에 포함되는 원소들의 최솟값들이다.
따라서 각 쿼리의 원소들을 저장해놓고 min 함수로 최솟값을 구한다.

처음에는 for문을 함수로 묶으려고 했으며, 원소들을 저장하지 않고 매번 min 여부를 확인했다.
그러나 이렇게 하는 시간이 너무 오래 걸리고 실수도 훨씬 많아진다. 또한 가독성도 더 나빴다.
구현 문제에서 원하는 것은 함수로 묶거나 효율을 극한으로 끌어올리는 것이 아니다.
따라서 해결할 것을 있는 그대로 짜는 것이 좋다.

# 배운 점
[2D list 레퍼런스는 불가능]
numpy를 쓰는게 아니라면
2d리스트의 일부분을 별칭으로 지정할 수 없다.
- (X) mat[i1:i2][j1:j2]

[시작인덱스 및 조작언패킹]
인덱스의 시작이 0인지 1인지 주의를 기울여야 한다.

문제에서 쿼리가 담고 있는 인덱스들을 0부터 시작하도록 할 때,
작업 능률 및 실수를 방지하기 위해 반복자를 이용하며,
효율성 방향에 따라 두 가지를 사용할 수 있다.
- 시간 효율: 이터레이터; iter([v - 1 for v in query])
- 공간 효율: 제너레이터; (v - 1 for v in query)
이 문제에서 유의미한 효과를 보지는 못했지만,
제너레이터는 시간 효율성이 아니라 메모리 효율을 위한 것임은 알아두어야 한다.

# 기타
['_'의 명칭]
- underscore: 밑줄 자체이며 하나의 문자다. 변수명 등에 사용되 밑줄의 정확한 명칭은 언더스코어다.
- underline: underbar보다 더 밑에 긋는다. 기호 아래에 추가되는 것으로, 강조 등의 역할을 한다.
- underbar: underline보다 다소 위쪽에 그어 비교적 기호와 닿아있기 쉽다. 기호 밑에 있는 줄을 의미하며, 기호에 포함되는 것으로 볼 수 있다.
"""
