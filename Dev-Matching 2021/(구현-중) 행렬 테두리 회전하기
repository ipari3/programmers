# https://programmers.co.kr/learn/courses/30/lessons/77485

def solution(rows, columns, queries):
    board = [[i*columns + j + 1 for j in range(columns)] for i in range(rows)]

    min_sequence = []
    for query in queries:
        r1, c1, r2, c2 = (v - 1 for v in query)
        elements = []
        
        i = r1
        elements.append(board[i][c1])
        for j in range(c1+1, c2+1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        # j = c2
        for i in range(r1+1, r2+1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        # i = r2
        for j in range(c2-1, c1-1, -1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        # j = c1
        for i in range(r2-1, r1-1, -1):
            elements.append(board[i][j])
            board[i][j] = elements[-2]
        
        min_sequence.append(min(elements))
    return min_sequence
    
"""
# 느낀 점
[구현은 담백하게 짜는 것이 좋다]
네모 모양을 이루며 회전이 이루어지는데, 이는 4개의 선분으로 나눌 수 있다.
따라서 4개의 for문으로 구현이 이루어진다.
또한 구하는 것은 결국 각 쿼리에서 회전에 포함되는 원소들의 최솟값들이다.
따라서 각 쿼리의 원소들을 저장해놓고 min 함수로 최솟값을 구한다.

처음에는 for문을 함수로 묶으려고 했으며, 원소들을 저장하지 않고 매번 min 여부를 확인했다.
그러나 이렇게 하는 시간이 너무 오래 걸리고 실수도 훨씬 많아진다. 또한 가독성도 더 나빴다.
구현 문제에서 원하는 것은 함수로 묶거나 효율을 극한으로 끌어올리는 것이 아니다.
따라서 해결할 것을 있는 그대로 짜는 것이 좋다.

또한 4개의 for문에서 더 확장할 것으로 생각되지 않으므로 애초에 함수화의 필요성을 느끼지 못하며,
쿼리의 원소들을 저장하는 것과 min 함수의 사용이 점근적 시간복잡도에 영향을 주지 않는다.

# 배운 점
[2D list 레퍼런스는 불가능]
numpy를 쓰는게 아니라면
2d리스트의 일부분을 별칭으로 지정할 수 없다.
- (X) mat[i1:i2][j1:j2]

[시작인덱스 및 조작언패킹]
인덱스의 시작이 0인지 1인지 주의를 기울여야 한다.

문제에서 쿼리가 담고 있는 인덱스들을 0부터 시작하도록 할 때,
작업 능률 및 실수를 방지하기 위해 반복자를 이용하며,
효율성 방향에 따라 두 가지를 사용할 수 있다.
- 시간 효율: 이터레이터; iter([v - 1 for v in query])
- 공간 효율: 제너레이터; (v - 1 for v in query)
이 문제에서 유의미한 효과를 보지는 못했지만,
제너레이터는 시간 효율성이 아니라 메모리 효율을 위한 것임은 알아두어야 한다.

# 
[대각선교환] 분할 
대각선 교환이 정사각행렬 내에서 이루어지면 전치행렬의 방식으로 쉽게 구현할 수 있지만,
직사각행렬에 대해 틀은 그대로 두고 원소들만 교환해야하면 구현이 복잡해진다.
이 경우 행렬축에 대한 기울기가 1인 경우와 -1인 경우가 존재한다.
- (r + c)가 동일한 원소끼리 교환되는 형태
- (r - c)가 동일한 원소끼리 교환되는 형태
위의 원소들에서 일반적인 전치와 마찬가지로 가장 먼 원소끼리, 가장 가까운 원소끼리 교환하게 된다.

이 문제의 각 쿼리도 시작점 (r1, c1)과 끝점 (r2, c2)를 포함하며, 추가로 기울기에 대한 정보를 포함한다.
그런데 이 경우는 함수를 이용하여 구현하는 것이 나을 것이다.
그렇지 않으면, 총 4가지 경우에 대해 복합적으로 생각하면서 구현해야 한다.
(기울기에 대한 경우의 수 2가지 x 직사각형이 가로로 긴 경우와 세로로 긴 경우의 2가지)
반면 함수를 이용하면 기울기 2가지에 대해서만 구현하면 된다.
직사각형 비율에 대해서도 고려해야 하긴 하지만, 기울기에 대한 고려와 분리하여 생각할 수 있다.

함수의 파라미터는 r과 c에 대한 1차함수의 시점과 종점일 것이다.
직사각형에 대한 고려 방법은 여러가지가 있을 수 있겠지만,
양끝 삼각형과 그 사이 평행사변형으로 나누는 방법을 생각해볼 수 있다.

이렇게 적절히 분할하여 각각을 정복하는 해결 방법은 매우 유용하다. 
"""
